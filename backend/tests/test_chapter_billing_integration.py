import pytest
import asyncio
from unittest.mock import Mock, AsyncMock, patch
from fastapi.testclient import TestClient

from backend.main import app
from backend.services.credits_service import InsufficientCreditsError


@pytest.fixture
def test_client():
    """Test client for FastAPI app."""
    return TestClient(app)


@pytest.fixture
def mock_user_id():
    """Test user ID."""
    return "test_user_integration_123"


@pytest.fixture
def mock_project_id():
    """Test project ID."""
    return "test_project_integration_456"


@pytest.mark.asyncio
async def test_chapter_generation_successful_billing_flow():
    """
    Integration test: Chapter generation with successful credit deduction.
    Tests end-to-end flow from API request to credit deduction.
    """
    user_id = "test_user_integration_123"
    project_id = "test_project_integration_456"
    
    # Mock successful chapter generation response
    mock_chapter_content = {
        "content": "This is a test chapter content generated by the AI...",
        "title": "Test Chapter",
        "word_count": 1500,
        "stage": "stage_2_first_draft"
    }
    
    # Mock credit balance with sufficient credits
    mock_balance = Mock()
    mock_balance.balance = 500
    mock_balance.pending_debits = 0
    
    # Mock successful credit deduction transaction
    mock_transaction = Mock()
    mock_transaction.txn_id = "chapter_txn_123"
    mock_transaction.amount = 25  # Typical cost for chapter generation
    
    with patch('backend.routers.chapters_v2.get_credits_service') as mock_get_credits_service, \
         patch('backend.routers.chapters_v2.create_billable_openai_client') as mock_create_client, \
         patch('backend.routers.chapters_v2.get_user') as mock_get_user, \
         patch('backend.routers.chapters_v2.get_project') as mock_get_project:
        
        # Mock credits service
        mock_credits_service = Mock()
        mock_credits_service.is_available.return_value = True
        mock_credits_service.get_balance = AsyncMock(return_value=mock_balance)
        mock_get_credits_service.return_value = mock_credits_service
        
        # Mock billable OpenAI client
        mock_openai_client = Mock()
        mock_billable_response = Mock()
        mock_billable_response.response.choices = [Mock()]
        mock_billable_response.response.choices[0].message.content = mock_chapter_content["content"]
        mock_billable_response.credits_charged = 25
        mock_billable_response.transaction_id = "chapter_txn_123"
        mock_openai_client.chat_completions_create = AsyncMock(return_value=mock_billable_response)
        mock_create_client.return_value = mock_openai_client
        
        # Mock user and project data
        mock_get_user.return_value = {"id": user_id, "email": "test@example.com"}
        mock_get_project.return_value = {
            "id": project_id,
            "title": "Test Project",
            "genre": "Fiction",
            "user_id": user_id
        }
        
        # Mock Firestore operations for chapter saving
        with patch('backend.services.firestore_service.FirestoreService') as mock_firestore:
            mock_firestore_instance = Mock()
            mock_firestore_instance.save_chapter = AsyncMock(return_value=True)
            mock_firestore.return_value = mock_firestore_instance
            
            # Make chapter generation request
            test_client = TestClient(app)
            
            response = test_client.post(
                f"/v2/chapters/{project_id}/generate",
                json={
                    "chapter_number": 1,
                    "stage": "stage_2_first_draft",
                    "context": "Test chapter context"
                },
                headers={"Authorization": f"Bearer mock_token_{user_id}"}
            )
            
            # Verify successful response
            assert response.status_code == 200
            response_data = response.json()
            
            # Verify chapter data structure
            assert "content" in response_data
            assert "word_count" in response_data
            assert "credits_charged" in response_data
            assert response_data["credits_charged"] == 25
            assert "transaction_id" in response_data
            
            # Verify OpenAI client was called with billing enabled
            mock_create_client.assert_called_once()
            assert mock_create_client.call_args[1]["enable_billing"] is True
            
            # Verify chat completion was called
            mock_openai_client.chat_completions_create.assert_called_once()


@pytest.mark.asyncio
async def test_chapter_generation_insufficient_credits_returns_402():
    """
    Integration test: Chapter generation fails with HTTP 402 when insufficient credits.
    """
    user_id = "test_user_low_credits_123"
    project_id = "test_project_integration_456"
    
    with patch('backend.routers.chapters_v2.get_credits_service') as mock_get_credits_service, \
         patch('backend.routers.chapters_v2.create_billable_openai_client') as mock_create_client, \
         patch('backend.routers.chapters_v2.get_user') as mock_get_user, \
         patch('backend.routers.chapters_v2.get_project') as mock_get_project:
        
        # Mock credits service with low balance
        mock_credits_service = Mock()
        mock_credits_service.is_available.return_value = True
        mock_balance = Mock()
        mock_balance.balance = 5  # Insufficient credits
        mock_balance.pending_debits = 0
        mock_credits_service.get_balance = AsyncMock(return_value=mock_balance)
        mock_get_credits_service.return_value = mock_credits_service
        
        # Mock billable OpenAI client that raises insufficient credits error
        mock_openai_client = Mock()
        from fastapi import HTTPException
        insufficient_credits_error = HTTPException(
            status_code=402, 
            detail={
                "error": "INSUFFICIENT_CREDITS",
                "message": "Insufficient credits for this operation",
                "user_id": user_id
            }
        )
        mock_openai_client.chat_completions_create = AsyncMock(side_effect=insufficient_credits_error)
        mock_create_client.return_value = mock_openai_client
        
        # Mock user and project data
        mock_get_user.return_value = {"id": user_id, "email": "test@example.com"}
        mock_get_project.return_value = {
            "id": project_id,
            "title": "Test Project",
            "user_id": user_id
        }
        
        # Make chapter generation request
        test_client = TestClient(app)
        
        response = test_client.post(
            f"/v2/chapters/{project_id}/generate",
            json={
                "chapter_number": 1,
                "stage": "stage_2_first_draft",
                "context": "Test chapter context"
            },
            headers={"Authorization": f"Bearer mock_token_{user_id}"}
        )
        
        # Verify 402 Payment Required response
        assert response.status_code == 402
        response_data = response.json()
        
        assert response_data["detail"]["error"] == "INSUFFICIENT_CREDITS"
        assert response_data["detail"]["user_id"] == user_id


@pytest.mark.asyncio
async def test_chapter_generation_openai_failure_no_credit_deduction():
    """
    Integration test: OpenAI API failure should not result in credit deduction.
    Tests provisional debit rollback on operation failure.
    """
    user_id = "test_user_api_failure_123"
    project_id = "test_project_integration_456"
    
    with patch('backend.routers.chapters_v2.get_credits_service') as mock_get_credits_service, \
         patch('backend.routers.chapters_v2.create_billable_openai_client') as mock_create_client, \
         patch('backend.routers.chapters_v2.get_user') as mock_get_user, \
         patch('backend.routers.chapters_v2.get_project') as mock_get_project:
        
        # Mock credits service with sufficient balance
        mock_credits_service = Mock()
        mock_credits_service.is_available.return_value = True
        mock_balance = Mock()
        mock_balance.balance = 500
        mock_balance.pending_debits = 0
        mock_credits_service.get_balance = AsyncMock(return_value=mock_balance)
        mock_get_credits_service.return_value = mock_credits_service
        
        # Mock billable OpenAI client that raises API error
        mock_openai_client = Mock()
        api_error = Exception("OpenAI API rate limit exceeded")
        mock_openai_client.chat_completions_create = AsyncMock(side_effect=api_error)
        mock_create_client.return_value = mock_openai_client
        
        # Mock user and project data
        mock_get_user.return_value = {"id": user_id, "email": "test@example.com"}
        mock_get_project.return_value = {
            "id": project_id,
            "title": "Test Project",
            "user_id": user_id
        }
        
        # Make chapter generation request
        test_client = TestClient(app)
        
        response = test_client.post(
            f"/v2/chapters/{project_id}/generate",
            json={
                "chapter_number": 1,
                "stage": "stage_2_first_draft",
                "context": "Test chapter context"
            },
            headers={"Authorization": f"Bearer mock_token_{user_id}"}
        )
        
        # Verify error response (should be 500 Internal Server Error)
        assert response.status_code == 500
        
        # In a real implementation with provisional debits:
        # 1. Provisional debit would be created before OpenAI call
        # 2. On OpenAI failure, provisional debit would be voided
        # 3. No actual credits would be deducted from user balance
        # This test verifies the error handling path exists


@pytest.mark.asyncio
async def test_reference_generation_billing_integration():
    """
    Integration test: Reference generation (characters, outline) billing flow.
    """
    user_id = "test_user_ref_gen_123"
    project_id = "test_project_integration_456"
    
    # Mock successful reference generation
    mock_reference_content = {
        "characters": [
            {
                "name": "John Doe",
                "description": "Main protagonist...",
                "role": "protagonist"
            }
        ]
    }
    
    with patch('backend.utils.reference_content_generator.create_billable_openai_client') as mock_create_client, \
         patch('backend.utils.reference_content_generator.get_credits_service') as mock_get_credits_service:
        
        # Mock credits service
        mock_credits_service = Mock()
        mock_credits_service.is_available.return_value = True
        mock_balance = Mock()
        mock_balance.balance = 200
        mock_credits_service.get_balance = AsyncMock(return_value=mock_balance)
        mock_get_credits_service.return_value = mock_credits_service
        
        # Mock billable OpenAI client for reference generation
        mock_openai_client = Mock()
        mock_billable_response = Mock()
        mock_billable_response.response.choices = [Mock()]
        mock_billable_response.response.choices[0].message.content = str(mock_reference_content)
        mock_billable_response.credits_charged = 15
        mock_billable_response.transaction_id = "ref_txn_123"
        mock_openai_client.chat_completions_create = AsyncMock(return_value=mock_billable_response)
        mock_create_client.return_value = mock_openai_client
        
        # Test reference generation API call
        test_client = TestClient(app)
        
        response = test_client.post(
            "/references/characters",
            json={
                "project_id": project_id,
                "genre": "Fantasy",
                "context": "Medieval fantasy setting"
            },
            headers={"Authorization": f"Bearer mock_token_{user_id}"}
        )
        
        # Verify successful response
        assert response.status_code == 200
        response_data = response.json()
        
        # Verify billing information included
        assert "credits_charged" in response_data
        assert response_data["credits_charged"] == 15
        assert "transaction_id" in response_data


@pytest.mark.asyncio
async def test_cover_art_generation_billing_integration():
    """
    Integration test: Cover art generation billing with image models.
    """
    user_id = "test_user_cover_art_123"
    project_id = "test_project_integration_456"
    
    with patch('backend.services.cover_art_service.create_billable_openai_client') as mock_create_client, \
         patch('backend.services.cover_art_service.get_credits_service') as mock_get_credits_service:
        
        # Mock credits service
        mock_credits_service = Mock()
        mock_credits_service.is_available.return_value = True
        mock_balance = Mock()
        mock_balance.balance = 100
        mock_credits_service.get_balance = AsyncMock(return_value=mock_balance)
        mock_get_credits_service.return_value = mock_credits_service
        
        # Mock billable OpenAI client for image generation
        mock_openai_client = Mock()
        mock_billable_response = Mock()
        mock_billable_response.response.data = [Mock()]
        mock_billable_response.response.data[0].url = "https://example.com/cover.png"
        mock_billable_response.credits_charged = 20  # DALL-E 3 cost
        mock_billable_response.transaction_id = "cover_txn_123"
        mock_openai_client.images_generate = AsyncMock(return_value=mock_billable_response)
        mock_create_client.return_value = mock_openai_client
        
        # Test cover art generation API call
        test_client = TestClient(app)
        
        response = test_client.post(
            f"/cover-art/{project_id}",
            json={
                "title": "Test Book",
                "genre": "Science Fiction",
                "description": "A thrilling space adventure"
            },
            headers={"Authorization": f"Bearer mock_token_{user_id}"}
        )
        
        # Verify successful response
        assert response.status_code == 200
        response_data = response.json()
        
        # Verify billing and image data
        assert "credits_charged" in response_data
        assert response_data["credits_charged"] == 20
        assert "transaction_id" in response_data
        assert "image_url" in response_data


@pytest.mark.asyncio
async def test_credits_disabled_fallback_behavior():
    """
    Integration test: When credits system disabled, operations should still work.
    """
    user_id = "test_user_no_credits_123"
    project_id = "test_project_integration_456"
    
    with patch('backend.routers.chapters_v2.get_credits_service') as mock_get_credits_service, \
         patch('backend.routers.chapters_v2.create_billable_openai_client') as mock_create_client, \
         patch('backend.routers.chapters_v2.get_user') as mock_get_user, \
         patch('backend.routers.chapters_v2.get_project') as mock_get_project:
        
        # Mock credits service as unavailable
        mock_credits_service = Mock()
        mock_credits_service.is_available.return_value = False
        mock_get_credits_service.return_value = mock_credits_service
        
        # Mock billable OpenAI client with billing disabled
        mock_openai_client = Mock()
        mock_billable_response = Mock()
        mock_billable_response.response.choices = [Mock()]
        mock_billable_response.response.choices[0].message.content = "Chapter content without billing"
        mock_billable_response.credits_charged = 0  # No credits charged when disabled
        mock_billable_response.transaction_id = None
        mock_openai_client.chat_completions_create = AsyncMock(return_value=mock_billable_response)
        mock_create_client.return_value = mock_openai_client
        
        # Mock user and project data
        mock_get_user.return_value = {"id": user_id, "email": "test@example.com"}
        mock_get_project.return_value = {
            "id": project_id,
            "title": "Test Project",
            "user_id": user_id
        }
        
        # Mock Firestore operations
        with patch('backend.services.firestore_service.FirestoreService') as mock_firestore:
            mock_firestore_instance = Mock()
            mock_firestore_instance.save_chapter = AsyncMock(return_value=True)
            mock_firestore.return_value = mock_firestore_instance
            
            # Make chapter generation request
            test_client = TestClient(app)
            
            response = test_client.post(
                f"/v2/chapters/{project_id}/generate",
                json={
                    "chapter_number": 1,
                    "stage": "stage_2_first_draft",
                    "context": "Test chapter context"
                },
                headers={"Authorization": f"Bearer mock_token_{user_id}"}
            )
            
            # Verify successful response without credits charged
            assert response.status_code == 200
            response_data = response.json()
            
            assert "content" in response_data
            assert response_data.get("credits_charged", 0) == 0
            assert response_data.get("transaction_id") is None